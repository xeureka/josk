<!-- Generated by GitHub Copilot Chat Assistant -->

# ðŸš€ Josk â€” Multiâ€‘Tenant Credit Purchase Backend

An elegant, server-focused backend built for safe, concurrent multiâ€‘tenant credit purchases. Designed for correctness, consistency, and robust transactional behavior when handling money, inventory, and tenant isolation.

[![TypeScript](https://img.shields.io/badge/TypeScript-85.5%25-blue)]() [![JavaScript](https://img.shields.io/badge/JavaScript-14.5%25-yellow)]()

---

## Table of contents
- [Overview](#overview)
- [Key goals](#key-goals)
- [Architecture & core concepts](#architecture--core-concepts)
  - [Transactions](#transactions)
  - [Invariants](#invariants)
  - [Multiâ€‘tenancy](#multiâ€‘tenancy)
  - [Concurrency](#concurrency)
- [Domain model (conceptual)](#domain-model-conceptual)
- [Purchase flow (high level)](#purchase-flow-high-level)
- [Folder structure](#folder-structure)
- [Tech stack](#tech-stack)
- [Design decisions (Why this approach?)](#design-decisions-why-this-approach)
- [Notes & next steps](#notes--next-steps)

---

## Overview
This repository implements a backend-only system using Next.js (server-side) and PostgreSQL. Multiple businesses (tenants) share the same application and database while keeping their data strictly isolated. The design emphasizes correctness, auditability, and safety when performing financial and inventory operations.

---

## Key goals
- Strong correctness guarantees for financial and inventory operations.
- Multiâ€‘tenant data isolation with tenant-aware schema and queries.
- ACID transactions and rowâ€‘level locking to avoid race conditions and overselling.
- Full auditability via an appendâ€‘only credit ledger (no mutable balances).

---

## Architecture & core concepts

### Transactions
Purchases are executed as a single database transaction touching multiple tables (products, customers, orders, order_items, credit_ledger). Every validation and update happens inside the transaction so either the entire purchase succeeds or the database rolls back to the prior consistent state.

### Invariants
Enforced primarily at the database level:
- Product stock must never go below zero.
- Customer credit usage must never exceed their credit limit.
- Tenants cannot read or modify another tenant's data.
- Orders are immutable historical records created only after all validations succeed.

### Multiâ€‘tenancy
- Every table includes a `business_id` column.
- All queries and constraints are tenant-aware (use `business_id`).
- Compatible with PostgreSQL Row Level Security (RLS) / Supabase if you opt to add it.

### Concurrency
Rowâ€‘level locks are acquired on customer and product rows before validation and updates. This prevents overselling and overâ€‘crediting without relying on applicationâ€‘level locks.

---

## Domain model (conceptual)
- **Businesses** â€” tenants; other tables reference `business_id`.
- **Customers** â€” belong to a business; have a credit limit and credit activity tracked in the ledger.
- **Products** â€” belong to a business; have stock and a price. Stock updates are transactional and validated.
- **Orders** â€” immutable records representing completed purchases.
- **Order Items** â€” store quantity and purchaseâ€‘time price so historical orders remain accurate.
- **Credit Ledger** â€” appendâ€‘only ledger entries track credit usage (positive) and payments (negative). Current balance = sum of ledger entries.

---

## Purchase flow (high level)
1. Start a database transaction.  
2. Lock the customer row to prevent concurrent credit changes.  
3. Lock the product rows to prevent concurrent stock changes.  
4. Validate stock availability and credit limit.  
5. Create the order record.  
6. Insert `order_items`.  
7. Update product stock.  
8. Insert credit ledger entries.  
9. Commit the transaction.  
10. If any step fails, rollback to keep data consistent.

---

## Folder structure
High-level layout (may evolve):

```.
â”œâ”€ .gitignore
â”œâ”€ README.md
â”œâ”€ bun.lock
â”œâ”€ docker-compose.yml
â”œâ”€ eslint.config.mjs
â”œâ”€ next.config.ts
â”œâ”€ package.json
â”œâ”€ postcss.config.mjs
â”œâ”€ tsconfig.json
â””â”€ src/
   â”œâ”€ app/        # Next.js server routes and handlers (server-only)
   â”œâ”€ db/         # Database connection, queries and transaction helpers
   â”œâ”€ lib/        # Shared utilities and helpers
   â””â”€ types/      # TypeScript types and domain definitions
```

---

## Tech stack
- Language: TypeScript  
- Server: Next.js (server / API layer only)  
- Database: PostgreSQL (transactions, constraints, rowâ€‘level locks)  
- Containerization: Docker / Docker Compose  
- Tooling: Bun, ESLint

---

## Design decisions (Why this approach?)
- Use the database for correctness: constraints, transactions, and row locks provide fewer failure modes than distributed app locks.
- Ledger-based accounting avoids fragile mutable balances and gives a reproducible audit trail.
- Tenant-aware schemas + `business_id` minimize leakage risk and are straightforward to combine with RLS for even stronger isolation.
- Immutable orders preserve historical correctness for reporting and reconciliation.

---

## Notes & next steps
- No frontend is included â€” this project is purposefully server-only.
- The system favors correctness and auditability over premature optimization.
- If you enable RLS or Supabase, ensure application queries still include `business_id` filters or use auth-bound policies.
- The repository includes a bare SQL schema / migrations. Consider improving safety, maintainability, and developer ergonomics by using a query builder or an ORM (for example: Knex, Prisma, TypeORM).

---

*If you'd like, I can open a branch and create a PR with this change, or add a "Getting started" section â€” tell me which you prefer.*